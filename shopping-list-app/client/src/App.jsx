// client/src/App.jsx
// Description: Main application component handling state, routing, socket connections,
// offline logic, sync, authentication, and rendering core UI views.

import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { socket } from './socket';
import { useAutoAnimate } from '@formkit/auto-animate/react';
import { useTranslation } from 'react-i18next';
import AdminPinModal from './AdminPinModal';
import AdminPanel from './AdminPanel';
import ShoppingListDetail from './ShoppingListDetail';
import * as offlineService from './services/offlineService';
import SyncPromptModal from './components/SyncPromptModal';

// --- Helper Components ---
function LoadingOverlay() {
    return (
        <div className="fixed inset-0 bg-background/70 dark:bg-dark-background/70 backdrop-blur-sm flex justify-center items-center z-[999]">
            <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-primary dark:border-dark-primary"></div>
        </div>
    );
}

function SegmentedControl({ options, currentValue, onChange, ariaLabel }) { return ( <div className="inline-flex rounded-lg shadow-sm bg-gray-200 dark:bg-gray-700 p-0.5" role="group" aria-label={ariaLabel}> {options.map((option) => ( <button key={option.value} type="button" onClick={() => onChange(option.value)} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors duration-200 ease-in-out focus:z-10 focus:ring-2 focus:ring-offset-1 focus:ring-accent dark:focus:ring-dark-accent focus:ring-offset-gray-200 dark:focus:ring-offset-gray-700 outline-none flex items-center justify-center h-8 w-10 ${currentValue === option.value ? 'bg-white dark:bg-gray-500 shadow' : 'text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-600'}`} aria-pressed={currentValue === option.value} > <span className={`transition-opacity duration-150 ${currentValue === option.value ? 'opacity-100' : 'opacity-75 hover:opacity-100'}`}>{option.icon}</span> </button> ))} </div> ); }
function ThemeToggle({ isDarkMode, onToggle }) { const { t } = useTranslation(); const themeOptions = [ { value: 'light', icon: <span className="material-symbols-rounded text-lg leading-none">light_mode</span> }, { value: 'dark', icon: <span className="material-symbols-rounded text-lg leading-none">dark_mode</span> } ]; return <SegmentedControl options={themeOptions} currentValue={isDarkMode ? 'dark' : 'light'} onChange={(value) => onToggle(value === 'dark')} ariaLabel={t('theme_toggle_aria_label')} />; }
function LanguageToggle({ currentLang, onChangeLang }) { const { t } = useTranslation(); const languageOptions = [ { value: 'en', icon: <img src="/USA.png" alt="USA Flag" className="w-5 h-auto" /> }, { value: 'pl', icon: <img src="/Poland.png" alt="Poland Flag" className="w-5 h-auto" /> } ]; return <SegmentedControl options={languageOptions} currentValue={currentLang} onChange={onChangeLang} ariaLabel={t('language_toggle_aria_label')} />; }
function AddListModal({ isOpen, onClose, onAddList }) { const { t } = useTranslation(); const [listName, setListName] = useState(''); const [isPublic, setIsPublic] = useState(false); const inputRef = useRef(null); const [parent] = useAutoAnimate(); useEffect(() => { if (isOpen) { setTimeout(() => { inputRef.current?.focus(); }, 50); setListName(''); setIsPublic(false); } }, [isOpen]); useEffect(() => { const handleKeyDown = (event) => { if (event.key === 'Escape') onClose(); }; if (isOpen) window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [isOpen, onClose]); const handleSubmit = (e) => { e.preventDefault(); onAddList(listName.trim(), isPublic); onClose(); }; if (!isOpen) return null; return ( <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4 transition-opacity duration-200 ease-in-out" onClick={onClose} role="dialog" aria-modal="true" aria-labelledby="add-list-modal-title"> <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full transform transition-all duration-200 ease-in-out scale-95 opacity-0 animate-modal-enter" onClick={(e) => e.stopPropagation()} ref={parent}> <h2 id="add-list-modal-title" className="text-xl font-semibold mb-4 text-primary dark:text-dark-primary">{t('create_list_button')}</h2> <form onSubmit={handleSubmit}> <input ref={inputRef} type="text" value={listName} onChange={(e) => setListName(e.target.value)} placeholder={t('new_list_placeholder')} className="w-full p-2 border rounded bg-white dark:bg-gray-700 text-text dark:text-dark-text border-primary dark:border-dark-primary focus:ring-accent dark:focus:ring-dark-accent mb-4" aria-label={t('new_list_placeholder')} maxLength={100} /> <div className="mb-4 flex items-center justify-start gap-3 bg-gray-100 dark:bg-gray-700 p-2 rounded-md"> <label htmlFor="list-privacy-toggle" className="text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer flex items-center gap-2"><span className={`material-symbols-rounded text-lg ${isPublic ? 'text-blue-500' : 'text-yellow-600'}`}> {isPublic ? 'public' : 'lock'} </span>{isPublic ? t('list_privacy_public') : t('list_privacy_private')}</label> <button type="button" id="list-privacy-toggle" onClick={() => setIsPublic(!isPublic)} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-100 dark:focus:ring-offset-gray-700 focus:ring-primary dark:focus:ring-dark-primary ${isPublic ? 'bg-blue-500' : 'bg-gray-400 dark:bg-gray-500'}`} aria-pressed={isPublic} aria-label={t('list_privacy_toggle_label')}> <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform duration-200 ease-in-out ${isPublic ? 'translate-x-6' : 'translate-x-1'}`} /> </button> <span className="text-xs text-gray-500 dark:text-gray-400 flex-shrink min-w-0"> ({isPublic ? t('list_public_info_short') : t('list_private_info_short')}) </span> </div> <div className="flex justify-end gap-3"><button type="button" onClick={onClose} className="px-4 py-2 rounded bg-gray-200 dark:bg-gray-600 text-text dark:text-dark-text hover:opacity-80 transition-opacity">{t('cancel_button')}</button><button type="submit" className="px-4 py-2 rounded bg-accent dark:bg-dark-accent text-white hover:opacity-90 transition-opacity">{t('create_button')}</button></div> </form> </div> </div> ); }
function ShoppingLists({ lists, onSelectList, onAddList }) { const { t } = useTranslation(); const [listAnimationParent] = useAutoAnimate(); const [isAddListModalOpen, setIsAddListModalOpen] = useState(false); const handleOpenModal = () => setIsAddListModalOpen(true); const handleCloseModal = () => setIsAddListModalOpen(false); const handleAddListAndCloseModal = (name, isPublic) => { onAddList(name, isPublic); handleCloseModal(); }; const sortedLists = useMemo(() => { if (!Array.isArray(lists)) return []; return [...lists].sort((a, b) => (a.name || '').localeCompare(b.name || '')); }, [lists]); return ( <div className="p-4 bg-white dark:bg-gray-800 shadow-md rounded-lg"> <h1 className="text-3xl font-bold mb-6 text-center text-primary dark:text-dark-primary">{t('app_title')}</h1> {(lists || []).length === 0 ? (<p className="text-center text-gray-500 dark:text-gray-400">{t('no_lists_message')}</p>) : (<ul ref={listAnimationParent} className="space-y-2 list-none p-0 mb-6"> {sortedLists.map(list => ( <li key={list._id || list.tempId} className="flex justify-between items-center p-3 bg-secondary/30 dark:bg-dark-secondary/30 rounded cursor-pointer hover:bg-secondary/50 dark:hover:bg-dark-secondary/50 transition-colors" onClick={() => onSelectList(list._id || list.tempId)} role="button" tabIndex={0} onKeyDown={(e) => (e.key === 'Enter' || e.key === ' ') && onSelectList(list._id || list.tempId)}> <div className="flex items-center gap-2 min-w-0 mr-2"> <span title={list.isPublic ? t('list_status_public') : t('list_status_private')} className={`material-symbols-rounded text-base ${list.isPublic ? 'text-blue-500' : 'text-yellow-600'}`} aria-hidden="true">{list.isPublic ? 'public' : 'lock'}</span> <span className="font-medium text-text dark:text-dark-text break-words truncate">{list.name}</span> {list.isOffline && ( <span className="material-symbols-rounded text-xs text-amber-500 ml-1 flex-shrink-0" title={t('offline_change_tooltip')}>cloud_off</span> )} {list?.owner?.username && <span className="text-xs text-gray-500 dark:text-gray-400 flex-shrink-0">({list.owner.username})</span>} </div> <span className="material-symbols-rounded text-primary dark:text-dark-primary flex-shrink-0" aria-hidden="true">chevron_right</span> </li>))} </ul>)} <div className="mt-6 pt-4 border-t border-secondary dark:border-dark-secondary flex justify-center"><button type="button" onClick={handleOpenModal} className="w-full sm:w-auto px-5 py-2 bg-accent dark:bg-dark-accent text-white rounded hover:opacity-90 flex items-center justify-center gap-2 transition-opacity"><span className="material-symbols-rounded">add</span>{t('create_list_button')}</button></div> <AddListModal isOpen={isAddListModalOpen} onClose={handleCloseModal} onAddList={handleAddListAndCloseModal} /> </div> ); }
function Login({ onLogin, error, setError }) { const { t } = useTranslation(); const [username, setUsername] = useState(''); const [pin, setPin] = useState(''); const [isLoading, setIsLoading] = useState(false); const API_URL = import.meta.env.VITE_SERVER_URL; const handleSubmit = async (e) => { e.preventDefault(); if (!username || !pin || pin.length !== 4 || !/^\d{4}$/.test(pin)) { setError(t('login_invalid_input')); return; } setIsLoading(true); setError(null); try { const res = await fetch(`${API_URL}/api/auth/login`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ username, pin }), credentials: 'include' }); const data = await res.json(); if (!res.ok) throw new Error(data.message || t('login_failed_generic')); onLogin(data); } catch (err) { setError(err.message || t('login_failed_generic')); } finally { setIsLoading(false); } }; return ( <div className="flex flex-col items-center justify-center min-h-screen bg-background dark:bg-dark-background p-4"> <div className="w-full max-w-xs p-6 bg-white dark:bg-gray-800 rounded-lg shadow-md"><h1 className="text-2xl font-bold mb-6 text-center text-primary dark:text-dark-primary">{t('login_title')}</h1>{error && <p className="mb-4 text-center text-red-600 dark:text-red-400 bg-red-100 dark:bg-red-900/50 p-2 rounded text-sm">{error}</p>} <form onSubmit={handleSubmit}><div className="mb-4"><label htmlFor="username" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">{t('username_label')}</label><input type="text" id="username" value={username} onChange={(e) => setUsername(e.target.value.toLowerCase())} required className="w-full p-2 border rounded bg-white dark:bg-gray-700 text-text dark:text-dark-text border-primary dark:border-dark-primary focus:ring-accent dark:focus:ring-dark-accent" autoCapitalize="none" /></div> <div className="mb-6"><label htmlFor="pin" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">{t('pin_label')}</label><input type="password" id="pin" value={pin} onChange={(e) => setPin(e.target.value.replace(/\D/g,''))} required maxLength="4" minLength="4" inputMode="numeric" pattern="\d{4}" className="w-full p-2 border rounded bg-white dark:bg-gray-700 text-text dark:text-dark-text border-primary dark:border-dark-primary focus:ring-accent dark:focus:ring-dark-accent" /></div> <button type="submit" disabled={isLoading} className="w-full px-4 py-2 rounded bg-accent dark:bg-dark-accent text-white hover:opacity-90 transition-opacity disabled:opacity-50 flex items-center justify-center">{isLoading ? <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div> : t('login_button')}</button> </form> </div> </div> ); }

// --- Main App Component ---
function App() {
    const { t, i18n } = useTranslation();
    const [isConnected, setIsConnected] = useState(socket.connected);
    const [isOnline, setIsOnline] = useState(true);
    const [isSocketAttempted, setIsSocketAttempted] = useState(false);
    const [isDarkMode, setIsDarkMode] = useState(() => { const stored = localStorage.getItem('theme'); if (stored) return stored === 'dark'; return window.matchMedia('(prefers-color-scheme: dark)').matches; });
    const [currentLanguage, setCurrentLanguage] = useState(i18n.language.split('-')[0]);
    const [currentUser, setCurrentUser] = useState(null);
    const [isAuthLoading, setIsAuthLoading] = useState(true); // Starts true for initial session check
    const [authError, setAuthError] = useState(null);
    const [lists, setLists] = useState([]);
    const [currentListId, setCurrentListId] = useState(null);
    const [isLoading, setIsLoading] = useState(false); // For list fetching API calls
    const [isSyncing, setIsSyncing] = useState(false); // For sync operation
    const [error, setError] = useState(null);
    const [currentView, setCurrentView] = useState('login');
    const [isAdminPinModalOpen, setIsAdminPinModalOpen] = useState(false);
    const [isAdminVerified, setIsAdminVerified] = useState(false);
    const [adminPinError, setAdminPinError] = useState(null);
    const [pendingActions, setPendingActions] = useState(() => offlineService.getPendingActions());
    const [showSyncPrompt, setShowSyncPrompt] = useState(false);

    const currentListIdRef = useRef(currentListId);
    useEffect(() => { currentListIdRef.current = currentListId; }, [currentListId]);
    const API_URL = import.meta.env.VITE_SERVER_URL;

    // Theme and Language Effects
    useEffect(() => { if (isDarkMode) { document.documentElement.classList.add('dark'); localStorage.setItem('theme', 'dark'); } else { document.documentElement.classList.remove('dark'); localStorage.setItem('theme', 'light'); } }, [isDarkMode]);
    const toggleTheme = (isDark) => setIsDarkMode(isDark);
    const changeLanguage = (lng) => i18n.changeLanguage(lng);
    useEffect(() => { const handler = (lng) => setCurrentLanguage(lng.split('-')[0]); i18n.on('languageChanged', handler); setCurrentLanguage(i18n.language.split('-')[0]); return () => i18n.off('languageChanged', handler); }, [i18n]);

    // --- Refined Online Status Effect ---
    useEffect(() => { let onlineStatus = navigator.onLine; if (currentUser && isSocketAttempted) { onlineStatus = isConnected; } setIsOnline(onlineStatus); const handleBrowserOnline = () => { console.log("Browser online event."); setIsOnline(true); if (!socket.connected && currentUser && isSocketAttempted) { console.log("Browser online, attempting socket reconnect."); socket.connect(); } }; const handleBrowserOffline = () => { console.log("Browser offline event."); setIsOnline(false); }; window.addEventListener('online', handleBrowserOnline); window.addEventListener('offline', handleBrowserOffline); return () => { window.removeEventListener('online', handleBrowserOnline); window.removeEventListener('offline', handleBrowserOffline); }; }, [isConnected, isSocketAttempted, currentUser]);
    // --- Logout Function ---
    const handleLogout = useCallback(async (msgKey = null) => { const message = msgKey ? t(msgKey) : t('logout_successful'); setError(null); setAuthError(message); setCurrentUser(null); setLists([]); setCurrentListId(null); setIsAdminVerified(false); setIsAdminPinModalOpen(false); setAdminPinError(null); setCurrentView('login'); setShowSyncPrompt(false); setIsSyncing(false); offlineService.storeLists([]); offlineService.clearPendingActions(); setPendingActions([]); setIsSocketAttempted(false); if (socket.connected) socket.disconnect(); if (API_URL) try { await fetch(`${API_URL}/api/auth/logout`, { method: 'POST', credentials: 'include' }); } catch (err) { console.error("Logout API failed:", err); } }, [API_URL, t]);
    // --- handleBackToLists ---
    const handleBackToLists = useCallback(() => { if (!currentUser) return; if (currentListIdRef.current && socket.connected) { socket.emit('leaveList', currentListIdRef.current); } setCurrentListId(null); setError(null); }, [currentUser]);
    // --- Fetch Lists ---
    const fetchLists = useCallback(async (calledDuringSync = false) => { if (!currentUser || !API_URL) { console.log("FetchLists skipped: no user or API_URL."); return; } if (!socket.connected && !calledDuringSync) { console.log("FetchLists skipped: not connected."); return; } if (isLoading || (isSyncing && !calledDuringSync)) { console.log("FetchLists skipped: already loading or syncing."); return; } console.log("Fetching lists (with items) from server..."); setIsLoading(true); setError(null); try { const res = await fetch(`${API_URL}/api/lists`, { credentials: 'include' }); if (!res.ok) { const data = await res.json().catch(() => ({})); if (res.status === 401) { handleLogout('session_expired_error'); } else { throw new Error(data.message || t('error_fetching_lists')); } return; } const serverLists = await res.json(); const cleanServerLists = (serverLists || []).map(list => ({ ...list, isOffline: false, items: (list.items || []).map(item => ({ ...item, isOffline: false })) })); setLists(cleanServerLists); offlineService.storeLists(cleanServerLists); console.log("Lists fetched and stored locally."); setError(null); } catch (err) { console.error("Error fetching lists:", err); setError(err.message); } finally { setIsLoading(false); } }, [API_URL, currentUser, handleLogout, t, isLoading, isSyncing]);
    // --- Initial Load Effect ---
    useEffect(() => { const check = async () => { setIsAuthLoading(true); setAuthError(null); const storedLists = offlineService.getStoredLists(); setLists(storedLists); const storedActions = offlineService.getPendingActions(); setPendingActions(storedActions); if (!API_URL) { setAuthError("Config Error: Server URL missing."); setCurrentUser(null); setIsAuthLoading(false); setCurrentView('login'); setIsSocketAttempted(true); return; } try { const res = await fetch(`${API_URL}/api/auth/session`, { credentials: 'include' }); if (res.status === 401) { setCurrentUser(null); setCurrentView('login'); if (socket.connected) socket.disconnect(); } else if (res.ok) { const data = await res.json(); setCurrentUser(data); setCurrentView('lists'); if (!socket.connected) { console.log("Auth valid, attempting socket connection..."); socket.connect(); } else { console.log("Auth valid, socket already connected."); setIsConnected(true); setIsSocketAttempted(true); const currentPendingActions = offlineService.getPendingActions(); if (currentPendingActions.length > 0) { setShowSyncPrompt(true); } else { fetchLists(); } } } else { const errorData = await res.json().catch(() => ({ message: 'Failed to parse session error' })); throw new Error(errorData.message || t('session_check_failed')); } } catch (err) { console.error("Session check failed:", err); setAuthError(err.message || t('network_error')); setCurrentUser(null); setCurrentView('login'); if (socket.connected) socket.disconnect(); } finally { setIsAuthLoading(false); if (!currentUser || socket.connected) { setIsSocketAttempted(true); } } }; check(); }, [API_URL, t]);

    // --- Socket Event Handling ---
    useEffect(() => { if (!currentUser) { if (socket.connected) { console.log("User logged out, disconnecting socket."); socket.disconnect(); setIsConnected(false); } return; }
        // ** MODIFIED onConnect **
        const onConnect = () => {
            console.log('Socket connected');
            setIsConnected(true);
            setIsSocketAttempted(true);
            setError(null);
            const actions = offlineService.getPendingActions();
            setPendingActions(actions);

            // *** FIX: Only show prompt/fetch AFTER initial auth load is complete ***
            if (!isAuthLoading && actions.length > 0) {
                 console.log('Pending actions found on connect (auth loaded), showing sync prompt.');
                 setShowSyncPrompt(true);
             } else if (!isAuthLoading && actions.length === 0) {
                 console.log('No pending actions (auth loaded), fetching lists on connect.');
                 fetchLists();
             } else {
                 // This case means isAuthLoading is still true when connect fires.
                 // The initial useEffect's finally block will handle fetching or prompting.
                 console.log('Socket connected during initial auth load. Action/fetch deferred.');
             }

            if (currentListIdRef.current) { socket.emit('joinList', currentListIdRef.current); }
        };
        const onDisconnect = (reason) => { console.log('Socket disconnected:', reason); setIsConnected(false); setIsSocketAttempted(true); if (reason === 'io server disconnect') { if(!isAuthLoading) handleLogout('session_expired_error'); } else if (reason !== 'io client disconnect') { if (currentView !== 'login') { setError(t('connection_lost_error')); } } };
        const onConnectError = (err) => { console.error('Socket connection error:', err); setIsConnected(false); setIsSocketAttempted(true); if (err.message.includes('Authentication error')) { if(!isAuthLoading) handleLogout('authentication_error'); } else { if (currentView !== 'login') { setError(t('connection_failed_error', { message: err.message })); } } };
        const onListsUpdated = (updatedList) => { console.log("Socket: listsUpdated - Received:", updatedList); setError(null); setLists(currentLists => { const safeCurrentLists = currentLists || []; const listExists = safeCurrentLists.some(l => l._id === updatedList._id); let newLists; if (listExists) { newLists = safeCurrentLists.map(list => { if (list._id === updatedList._id) { const itemsFromServer = updatedList.items || []; const cleanItems = itemsFromServer.map(i => ({ ...i, isOffline: false })); return { ...list, ...updatedList, items: cleanItems, isOffline: false }; } return list; }); } else { const cleanNewListItems = (updatedList.items || []).map(i => ({...i, isOffline: false})); const cleanNewList = { ...updatedList, items: cleanNewListItems, isOffline: false }; newLists = [...safeCurrentLists, cleanNewList]; } offlineService.storeLists(newLists); return newLists; }); };
        const onListDeleted = (id) => { console.log("Socket: listDeleted - ID:", id); setError(null); setLists(currentLists => { const safeCurrentLists = currentLists || []; const newLists = safeCurrentLists.filter(l => l._id !== id); if (newLists.length < safeCurrentLists.length) { offlineService.storeLists(newLists); } return newLists; }); if (currentListIdRef.current === id) { handleBackToLists(); } };
        const onItemAdded = (newItem) => { console.log("Socket: itemAdded - Received:", newItem); if (!newItem || !newItem.listId || !newItem._id) { return; } setError(null); setLists(currentLists => { const safeCurrentLists = currentLists || []; const listIndex = safeCurrentLists.findIndex(l => l._id === newItem.listId); if (listIndex === -1) { return safeCurrentLists; } const targetList = safeCurrentLists[listIndex]; const currentItems = Array.isArray(targetList.items) ? targetList.items : []; const updatedItems = [...currentItems]; const newItemFromServer = { ...newItem, isOffline: false }; if (!updatedItems.some(i => i._id === newItemFromServer._id)) { updatedItems.push(newItemFromServer); const updatedList = { ...targetList, items: updatedItems, isOffline: false }; const newLists = [...safeCurrentLists]; newLists[listIndex] = updatedList; offlineService.storeLists(newLists); return newLists; } else { console.warn(`Item ${newItem._id} already exists in list ${newItem.listId}, ignoring duplicate add event.`); return safeCurrentLists; } }); };
        const onItemUpdated = (updatedItem) => { console.log("Socket: itemUpdated - Received:", updatedItem); if (!updatedItem || !updatedItem.listId || !updatedItem._id) { return; } setError(null); setLists(currentLists => { const safeCurrentLists = currentLists || []; const listIndex = safeCurrentLists.findIndex(l => l._id === updatedItem.listId); if (listIndex === -1) { return safeCurrentLists; } const targetList = safeCurrentLists[listIndex]; const currentItems = Array.isArray(targetList.items) ? targetList.items : []; let itemFound = false; const updatedItemFromServer = { ...updatedItem, isOffline: false }; const updatedItems = currentItems.map(item => { if (item._id === updatedItemFromServer._id) { itemFound = true; return updatedItemFromServer; } return item; }); if (itemFound) { const updatedList = { ...targetList, items: updatedItems, isOffline: false }; const newLists = [...safeCurrentLists]; newLists[listIndex] = updatedList; offlineService.storeLists(newLists); return newLists; } else { console.warn(`Item ${updatedItem._id} update received, but item not found in local list ${updatedItem.listId}.`); return safeCurrentLists; } }); };
        const onItemDeleted = ({ listId: lid, itemId }) => { console.log("Socket: itemDeleted - ListID:", lid, "ItemID:", itemId); if (!lid || !itemId) { return; } setError(null); setLists(currentLists => { const safeCurrentLists = currentLists || []; const listIndex = safeCurrentLists.findIndex(l => l._id === lid); if (listIndex === -1) { return safeCurrentLists; } const targetList = safeCurrentLists[listIndex]; const currentItems = Array.isArray(targetList.items) ? targetList.items : []; const initialLength = currentItems.length; const updatedItems = currentItems.filter(i => i._id !== itemId); if (updatedItems.length < initialLength) { const updatedList = { ...targetList, items: updatedItems, isOffline: false }; const newLists = [...safeCurrentLists]; newLists[listIndex] = updatedList; offlineService.storeLists(newLists); return newLists; } else { return safeCurrentLists; } }); };
        socket.on('connect', onConnect); socket.on('disconnect', onDisconnect); socket.on('connect_error', onConnectError); socket.on('listsUpdated', onListsUpdated); socket.on('listDeleted', onListDeleted); socket.on('itemAdded', onItemAdded); socket.on('itemUpdated', onItemUpdated); socket.on('itemDeleted', onItemDeleted);
        return () => { socket.off('connect', onConnect); socket.off('disconnect', onDisconnect); socket.off('connect_error', onConnectError); socket.off('listsUpdated', onListsUpdated); socket.off('listDeleted', onListDeleted); socket.off('itemAdded', onItemAdded); socket.off('itemUpdated', onItemUpdated); socket.off('itemDeleted', onItemDeleted); };
    }, [currentUser, currentView, t, handleLogout, handleBackToLists, fetchLists, isAuthLoading]); // Added isAuthLoading dependency

    // --- Item Actions Queueing (defined first) ---
    const queueItemAction = useCallback((action) => { console.log("Queueing item action:", action); const safeLists = lists || []; const newListsState = offlineService.applyActionLocally(safeLists, action); setLists(newListsState); const actionToQueue = { ...action, id: crypto.randomUUID() }; const updatedQueue = offlineService.addPendingAction(actionToQueue); setPendingActions(updatedQueue); setError(null); }, [lists]);
    // --- Action Handlers ---
    const handleLogin = (userData) => { setAuthError(null); setError(null); setCurrentUser(userData); setCurrentView('lists'); setIsSocketAttempted(false); if(socket.connected) { setIsConnected(true); const actions = offlineService.getPendingActions(); if (actions.length > 0) setShowSyncPrompt(true); else fetchLists(); } else { socket.connect(); } };
    const handleSelectList = (listId) => { if (!currentUser || currentListId === listId) return; if (currentListIdRef.current && isOnline) { socket.emit('leaveList', currentListIdRef.current); } setError(null); setCurrentListId(listId); if (isOnline) { socket.emit('joinList', listId); } };
    const handleAddList = (name, isPublic) => { if (!currentUser) return; const listName = name || t('default_list_name'); const tempListId = `temp_${crypto.randomUUID()}`; const optimisticList = { _id: tempListId, tempId: tempListId, name: listName, isPublic: isPublic, items: [], owner: { _id: currentUser._id, username: currentUser.username }, allowedUsers: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(), }; const originalLists = [...(lists || [])]; const action = { type: 'addList', payload: optimisticList }; const newListsState = offlineService.applyActionLocally(lists || [], action); setLists(newListsState); const syncPayload = { name: listName, isPublic }; const syncAction = { ...action, payload: { ...syncPayload, tempId: tempListId }, id: crypto.randomUUID() }; if (isOnline) { socket.emit(action.type, syncPayload, (res) => { if (res?.error) { setError(t('error_adding_list', { message: res.error })); setLists(originalLists); } else if (res?.newList) { setError(null); setLists(prev => { const updatedLists = (prev || []).map(l => l._id === tempListId ? { ...res.newList, isOffline: false } : l); if (!updatedLists.some(l => l._id === res.newList._id)) { updatedLists.push({...res.newList, isOffline: false}); } offlineService.storeLists(updatedLists); if (currentListIdRef.current === tempListId) { setCurrentListId(res.newList._id); } return updatedLists; }); } }); } else { const updatedQueue = offlineService.addPendingAction(syncAction); setPendingActions(updatedQueue); setError(null); } };
    const handleDeleteList = (listId) => { if (!currentUser) return; const safeLists = lists || []; const listToDelete = safeLists.find(l => l._id === listId || l.tempId === listId); if (!listToDelete) return; const originalLists = [...safeLists]; const effectiveListId = listToDelete._id || listToDelete.tempId; const isTemp = !!listToDelete.tempId && !listToDelete._id; const action = { type: 'deleteList', payload: { listId: effectiveListId } }; const newListsState = offlineService.applyActionLocally(safeLists, action); setLists(newListsState); if (currentListIdRef.current === effectiveListId) { setCurrentListId(null); } const syncAction = { ...action, payload: { listId: effectiveListId }, id: crypto.randomUUID() }; if (isOnline) { if (!isTemp) { socket.emit(action.type, action.payload.listId, (res) => { if (res?.error) { setError(t('error_deleting_list', { message: res.error })); setLists(originalLists); if (currentListIdRef.current === null && listToDelete._id === effectiveListId) setCurrentListId(effectiveListId); } else { setError(null); offlineService.storeLists(newListsState); } }); } else { console.log("Skipping delete emit for offline-only list."); setError(null); offlineService.storeLists(newListsState); } } else { const updatedQueue = offlineService.addPendingAction(syncAction); setPendingActions(updatedQueue); setError(null); } };
    const handleTogglePrivacy = useCallback((listId) => { const safeLists = lists || []; const list = safeLists.find(l => l._id === listId || l.tempId === listId); if (!list || !currentUser || list.owner._id !== currentUser._id) return; const effectiveListId = list._id; const isOfflineOnlyList = !!list.tempId && !list._id; const currentPrivacy = list.isPublic; const action = { type: 'toggleListPrivacy', payload: { listId: effectiveListId || list.tempId, isPublic: !currentPrivacy } }; const originalLists = [...safeLists]; const newListsState = offlineService.applyActionLocally(safeLists, action); setLists(newListsState); const syncAction = { ...action, payload: { listId: effectiveListId || list.tempId, isPublic: !currentPrivacy }, id: crypto.randomUUID() }; if (isOnline) { if (!isOfflineOnlyList) { socket.emit('toggleListPrivacy', effectiveListId, (res) => { if (res?.error) { setError(t('error_updating_list', { message: res.error })); setLists(originalLists); } else { setError(null); offlineService.storeLists(newListsState); } }); } else { const updatedQueue = offlineService.addPendingAction(syncAction); setPendingActions(updatedQueue); setError(null); console.warn("Queued privacy toggle for an offline-created list while online."); } } else { const updatedQueue = offlineService.addPendingAction(syncAction); setPendingActions(updatedQueue); setError(null); } }, [lists, currentUser, isOnline, t]);
    const handleUpdateItemComment = useCallback((itemId, comment) => { if (!currentListIdRef.current || !itemId) return; const listId = currentListIdRef.current; const payload = { listId, itemId, comment }; if (isOnline) { console.log("Emitting updateItemComment (online):", payload); socket.emit('updateItemComment', payload, (res) => { if (res?.error) { console.error("Error updating comment online:", res.error); setError(t('error_updating_comment', { message: res.error })); } else { console.log("Comment updated online successfully:", res.item); setError(null); } }); } else { const action = { type: 'updateItemComment', payload }; console.log("Queueing updateItemComment (offline):", action); queueItemAction(action); } }, [isOnline, t, queueItemAction]);

    // --- Sync Logic ---
    const handleSyncConfirm = useCallback(async () => { const currentPending = pendingActions || []; if (!isOnline || currentPending.length === 0) { setShowSyncPrompt(false); return; } console.log(`Starting sync of ${currentPending.length} actions...`); setShowSyncPrompt(false); setIsSyncing(true); setError(t('syncing_changes')); let syncErrorOccurred = false; const successfulActionIds = new Set(); const actionsToSync = [...currentPending]; let currentListsState = lists || []; try { for (const action of actionsToSync) { await new Promise(resolve => setTimeout(resolve, 50)); if (!socket.connected) { syncErrorOccurred = true; setError(t('connection_lost_error')); console.error("Sync aborted: Socket disconnected."); break; } console.log(`Syncing action ID: ${action.id}, Type: ${action.type}, Payload:`, action.payload); try { const response = await new Promise((resolve, reject) => { let emitPayload; let eventName = action.type; const safeCurrentLists = currentListsState; if (eventName === 'addItem') { const list = safeCurrentLists.find(l => l._id === action.payload.listId || l.tempId === action.payload.listId); if (!list || !list._id || list.tempId) { resolve({ skipped: true, reason: 'List not synced yet' }); return; } emitPayload = { listId: list._id, itemName: action.payload.itemName }; } else if (eventName === 'deleteList') { const list = safeCurrentLists.find(l => l.tempId === action.payload.listId); if (list && !list._id) { resolve({ skipped: true, reason: 'Offline only list' }); return; } emitPayload = action.payload.listId; } else if (eventName === 'deleteItem' || eventName === 'toggleItem' || eventName === 'updateItemComment') { const list = safeCurrentLists.find(l => l._id === action.payload.listId || l.tempId === action.payload.listId); if (!list || !list._id || list.tempId) { resolve({ skipped: true, reason: 'List not synced yet' }); return; } const item = (list.items || []).find(i => i._id === action.payload.itemId || i.tempId === action.payload.itemId); if(!item || !item._id || item.tempId) { resolve({ skipped: true, reason: `Item not synced yet for ${eventName}` }); return; } emitPayload = { ...action.payload, listId: list._id, itemId: item._id }; } else if (eventName === 'toggleListPrivacy') { const list = safeCurrentLists.find(l => l._id === action.payload.listId || l.tempId === action.payload.listId); if (!list || !list._id || list.tempId) { resolve({ skipped: true, reason: 'List not synced yet' }); return; } emitPayload = list._id; } else if (eventName === 'addList') { emitPayload = { name: action.payload.name, isPublic: action.payload.isPublic }; } else { console.warn(`Unknown action type during sync: ${eventName}`); resolve({ skipped: true, reason: 'Unknown action type' }); return; } socket.emit(eventName, emitPayload, (res) => { console.log(`Response for action ${action.id} (${eventName}):`, res); if (res?.error) reject({ message: res.error, action }); else resolve(res); }); setTimeout(() => reject({ message: 'Sync timeout', action }), 10000); }); if(response?.skipped){ console.log(`Action ${action.id} (${action.type}) skipped: ${response.reason}`); successfulActionIds.add(action.id); continue; } console.log(`Action ${action.id} (${action.type}) synced successfully.`); successfulActionIds.add(action.id); if (action.type === 'addList' && response?.newList?._id && action.payload.tempId) { const tempId = action.payload.tempId; const serverList = response.newList; console.log(`Mapping temp list ID ${tempId} to server ID ${serverList._id}`); currentListsState = currentListsState.map(l => l._id === tempId ? { ...serverList, isOffline: false, tempId: undefined } : l ); if (!currentListsState.some(l => l._id === serverList._id)) { currentListsState.push({ ...serverList, isOffline: false, tempId: undefined }); } if(currentListIdRef.current === tempId) { setCurrentListId(serverList._id); } } else if (action.type === 'addItem' && response?.item?._id && action.payload.tempItemId) { const tempItemId = action.payload.tempItemId; const serverItem = response.item; console.log(`Mapping temp item ID ${tempItemId} to server ID ${serverItem._id}`); currentListsState = currentListsState.map(l => { if (l._id === serverItem.listId) { let itemMapped = false; const updatedItems = (l.items || []).map(i => { if (i._id === tempItemId) { itemMapped = true; return {...serverItem, isOffline: false, tempId: undefined }; } return i; }); if (!itemMapped && !updatedItems.some(i => i._id === serverItem._id)) { updatedItems.push({...serverItem, isOffline: false, tempId: undefined }); } return { ...l, items: updatedItems, isOffline: false }; } return l; }); } setLists(currentListsState); } catch (err) { console.error(`Sync error for action ${err.action?.id} (${err.action?.type || 'Unknown'}):`, err.message); syncErrorOccurred = true; setError(t('sync_failed') + ` (Action: ${err.action?.type || 'Unknown'})`); break; } } } catch (outerError) { console.error("Critical error during sync process:", outerError); syncErrorOccurred = true; setError(t('sync_failed') + ' (Critical Process Error)'); } finally { console.log(`Sync loop finished. Success IDs: ${[...successfulActionIds].join(', ')}`); const remainingActions = currentPending.filter(action => !successfulActionIds.has(action.id)); console.log(`Remaining pending actions: ${remainingActions.length}`); offlineService.storePendingActions(remainingActions); setPendingActions(remainingActions); if (!syncErrorOccurred && remainingActions.length === 0) { console.log("Sync completed successfully."); setError(null); await fetchLists(true); setError(t('sync_complete')); setTimeout(() => setError(null), 3000); } else if (syncErrorOccurred) { console.log("Sync failed or was interrupted."); } else { console.log("Sync finished, but some actions remain pending."); setError(t('sync_partially_complete')); await fetchLists(true); } setIsSyncing(false); } }, [isOnline, pendingActions, t, handleLogout, fetchLists, lists]);
    const handleSyncCancel = () => { setShowSyncPrompt(false); };
    // Admin Handlers
    const handleOpenAdminPinModal = () => { setAdminPinError(null); setIsAdminPinModalOpen(true); };
    const handleVerifyAdminPin = async (pin) => { if(!API_URL) { setAdminPinError("API URL not configured."); return; } setIsLoading(true); setAdminPinError(null); try { const res = await fetch(`${API_URL}/api/admin/verify-pin`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pin }), credentials: 'include' }); const data = await res.json(); if (!res.ok) { throw new Error(data.message || `Admin verification failed with status ${res.status}`); } setIsAdminVerified(true); setIsAdminPinModalOpen(false); setCurrentView('admin'); setError(null); setAuthError(null); } catch (err) { console.error("Admin PIN verification failed:", err); setAdminPinError(err.message || 'Admin verification failed'); } finally { setIsLoading(false); } };
    const handleExitAdminMode = () => { setIsAdminVerified(false); setCurrentView('lists'); };
    // Derived State
    const currentList = useMemo(() => { if (!currentUser || currentView !== 'lists' || !currentListId || !Array.isArray(lists)) return null; return lists.find(list => list._id === currentListId || list.tempId === currentListId); }, [currentUser, currentView, currentListId, lists]);
    const currentListItems = useMemo(() => { return currentList?.items || []; }, [currentList]);

    // Combined loading state for overlay
    const showLoadingOverlay = isAuthLoading || isLoading || isSyncing;

    // --- Render Logic ---
    // Render LoadingOverlay first if any loading state is true
    if (showLoadingOverlay) {
        return <LoadingOverlay />;
    }

    const showOfflineIndicator = !isOnline && isSocketAttempted;

    return (
        <div className="min-h-screen bg-background dark:bg-dark-background text-text dark:text-dark-text transition-colors duration-300 font-sans">
            {/* Conditional rendering based on view AFTER loading is complete */}
            {currentView === 'login' ? ( <Login onLogin={handleLogin} error={authError} setError={setAuthError} /> )
            : currentUser ? (
                <>
                    {/* Header */}
                    <div className="fixed top-0 left-0 right-0 z-20 flex justify-between items-center gap-3 p-4 bg-background/80 dark:bg-dark-background/80 backdrop-blur-sm border-b border-secondary dark:border-dark-secondary">
                        <div className="flex-1"></div> <div className="flex-1 text-center"></div>
                        <div className="flex flex-1 justify-end items-center gap-2 sm:gap-3">
                            {showOfflineIndicator && ( <div className="flex items-center gap-1.5 px-2.5 py-1 rounded-md text-xs bg-amber-100 dark:bg-amber-800/50 text-amber-800 dark:text-amber-100 shadow-sm border border-amber-300 dark:border-amber-700/50 animate-pulse" title={t('offline_mode_active')} > <span className="material-symbols-rounded text-sm leading-none">cloud_off</span> <span>{t('status_offline', 'Offline')}</span> </div> )}
                            {currentUser?.isAdmin && currentView !== 'admin' && <button onClick={handleOpenAdminPinModal} title={t('admin_button_title')} className="p-1.5 text-sm font-medium rounded-md transition-colors duration-200 ease-in-out text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-primary dark:focus:ring-dark-primary focus:ring-offset-background dark:focus:ring-offset-dark-background"><span className="material-symbols-rounded text-lg leading-none">admin_panel_settings</span></button>}
                            <button onClick={() => handleLogout()} title={t('logout_button_title')} className="p-1.5 text-sm font-medium rounded-md transition-colors duration-200 ease-in-out text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-primary dark:focus:ring-dark-primary focus:ring-offset-background dark:focus:ring-offset-dark-background"><span className="material-symbols-rounded text-lg leading-none">logout</span></button>
                            <LanguageToggle currentLang={currentLanguage} onChangeLang={changeLanguage} />
                            <ThemeToggle isDarkMode={isDarkMode} onToggle={toggleTheme} />
                        </div>
                    </div>

                    <main className="max-w-2xl mx-auto p-4 pt-20">
                        <div className="text-center mb-4 text-xs min-h-[1.2em]">
                             {error ? ( <span className="text-red-600 dark:text-red-400 font-semibold">{error}</span> ) : authError && currentView !== 'login' ? ( <span className="text-red-600 dark:text-red-400 font-semibold">{authError}</span>) : !isAuthLoading && !isLoading && !isSyncing && isOnline && isConnected ? ( <span className={`transition-opacity duration-300 text-green-600 dark:text-green-400`}>{t('status_connected')}</span> ) : null }
                        </div>
                        <div className="text-center mb-4 text-sm text-gray-500 dark:text-gray-400">{t('logged_in_as')} <span className="font-medium text-primary dark:text-dark-primary">{currentUser.username}</span></div>
                         {currentView === 'admin' ? ( <AdminPanel onExitAdminMode={handleExitAdminMode} /> )
                         : (
                             <> {isLoading && !currentList && currentView === 'lists' ? ( /* This specific isLoading condition might be redundant due to the main overlay */ <div className="flex justify-center items-center p-10"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary dark:border-dark-primary"></div><span className="ml-3 text-gray-500 dark:text-gray-400">{t('loading')}</span></div> )
                                : currentList ? ( <ShoppingListDetail key={currentList._id || currentList.tempId} list={currentList} items={currentListItems} currentUser={currentUser} isOnline={isOnline} queueItemAction={queueItemAction} onBack={handleBackToLists} onDeleteList={handleDeleteList} onError={setError} onTogglePrivacy={handleTogglePrivacy} onUpdateComment={handleUpdateItemComment} /> )
                                : ( <ShoppingLists lists={lists} onSelectList={handleSelectList} onAddList={handleAddList} /> )}
                             </>
                         )}
                    </main>
                    <AdminPinModal isOpen={isAdminPinModalOpen} onClose={() => setIsAdminPinModalOpen(false)} onVerify={handleVerifyAdminPin} error={adminPinError} setError={setAdminPinError} />
                    <SyncPromptModal isOpen={showSyncPrompt} onClose={handleSyncCancel} onConfirmSync={handleSyncConfirm} pendingActionCount={Array.isArray(pendingActions) ? pendingActions.length : 0} />
                </>
            ) : ( <div className="flex justify-center items-center min-h-screen"><p>Error: Not authenticated.</p></div> )}
        </div>
    );
}

export default App;